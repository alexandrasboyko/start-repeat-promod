"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.canBeProxed = exports.isPrimitive = exports.getType = exports.isType = exports.typesEnum = exports.isAsyncFunction = exports.isFunction = exports.isSymbol = exports.isBoolean = exports.isPromise = exports.isNumber = exports.isUndefined = exports.isMap = exports.isSet = exports.isString = exports.isNull = exports.isObject = exports.isArray = void 0;
const typesEnum = {
    object: '[object Object]',
    array: '[object Array]',
    set: '[object Set]',
    map: '[object Map]',
    function: '[object Function]',
    asyncFunction: '[object AsyncFunction]',
    promise: '[object Promise]',
    null: '[object Null]',
    string: '[object String]',
    undefined: '[object Undefined]',
    symbol: '[object Symbol]',
    number: '[object Number]',
    boolean: '[object Boolean]'
};
exports.typesEnum = typesEnum;
const pritiveTypes = [
    '[object Null]', 'null',
    '[object String]', 'string',
    '[object Undefined]', 'undefined',
    '[object Number]', 'number',
    '[object Boolean]', 'boolean'
];
const typesReverseEnum = {
    '[object Object]': 'object',
    '[object Array]': 'array',
    '[object Set]': 'set',
    '[object Function]': 'function',
    '[object AsyncFunction]': 'asyncFunction',
    '[object Promise]': 'promise',
    '[object Symbol]': 'symbol',
    '[object Map]': 'map',
    '[object Null]': 'null',
    '[object String]': 'string',
    '[object Undefined]': 'undefined',
    '[object Number]': 'number',
    '[object Boolean]': 'boolean'
};
function isPrimitive(arg) {
    return pritiveTypes.includes(Object.prototype.toString.call(arg));
}
exports.isPrimitive = isPrimitive;
function getType(arg) {
    return typesReverseEnum[Object.prototype.toString.call(arg)];
}
exports.getType = getType;
function isObject(arg) {
    return Object.prototype.toString.call(arg) === '[object Object]';
}
exports.isObject = isObject;
function isArray(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
}
exports.isArray = isArray;
function isNull(arg) {
    return Object.prototype.toString.call(arg) === '[object Null]';
}
exports.isNull = isNull;
function isString(arg) {
    return Object.prototype.toString.call(arg) === '[object String]';
}
exports.isString = isString;
function isUndefined(arg) {
    return Object.prototype.toString.call(arg) === '[object Undefined]';
}
exports.isUndefined = isUndefined;
function isSet(arg) {
    return Object.prototype.toString.call(arg) === '[object Set]';
}
exports.isSet = isSet;
function isMap(arg) {
    return Object.prototype.toString.call(arg) === '[object Map]';
}
exports.isMap = isMap;
function isSymbol(arg) {
    return Object.prototype.toString.call(arg) === '[object Symbol]';
}
exports.isSymbol = isSymbol;
function isNumber(arg) {
    return Object.prototype.toString.call(arg) === '[object Number]' && !isNaN(arg);
}
exports.isNumber = isNumber;
function isBoolean(arg) {
    return Object.prototype.toString.call(arg) === '[object Boolean]';
}
exports.isBoolean = isBoolean;
function isFunction(arg) {
    return Object.prototype.toString.call(arg) === '[object Function]';
}
exports.isFunction = isFunction;
function isAsyncFunction(arg) {
    return Object.prototype.toString.call(arg) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;
function isPromise(arg) {
    return Object.prototype.toString.call(arg) === '[object Promise]';
}
exports.isPromise = isPromise;
function isType(arg, typeArg) {
    return Object.prototype.toString.call(arg) === typesEnum[typeArg];
}
exports.isType = isType;
function canBeProxed(arg) {
    try {
        new Proxy(arg, {});
        return true;
    }
    catch (error) {
        return false;
    }
}
exports.canBeProxed = canBeProxed;
//# sourceMappingURL=types.js.map