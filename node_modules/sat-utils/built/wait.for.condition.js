"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.waitForCondition = void 0;
const types_1 = require("./types");
async function sleep(millisecond = 5 * 1000) {
    return new Promise((resolve) => setTimeout(resolve, millisecond));
}
exports.sleep = sleep;
const defaultOptions = {};
async function waitForCondition(callback, options = {}) {
    const mergedOpts = { ...defaultOptions, ...options };
    const { message, timeout = 5000, interval = 250, dontThrow = false, throwCustom, createMessage, analyseResult, waiterError = Error, } = mergedOpts;
    if (!types_1.isNumber(interval)) {
        throw new TypeError('interval should be a number');
    }
    if (!types_1.isNumber(timeout)) {
        throw new TypeError('timeout should be a number');
    }
    const start = Date.now();
    let result;
    while (Date.now() - start < timeout) {
        result = await callback();
        if (analyseResult) {
            if (await analyseResult(result)) {
                return result;
            }
        }
        if (result) {
            return result;
        }
        await sleep(interval);
    }
    if (dontThrow) {
        return result;
    }
    if (throwCustom) {
        return throwCustom();
    }
    if (!result) {
        const errorMessage = createMessage
            ? createMessage(timeout)
            : message
                ? message
                : `Required condition was not achieved during ${timeout} ms`;
        throw new waiterError(errorMessage);
    }
}
exports.waitForCondition = waitForCondition;
waitForCondition.setDefaultOpts = function (opts) {
    Object.keys(defaultOptions).forEach((key) => {
        delete defaultOptions[key];
    });
    Object.assign(defaultOptions, opts);
};
//# sourceMappingURL=wait.for.condition.js.map