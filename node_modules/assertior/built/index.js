"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssertionError = exports.initStepDeclarator = exports.expect = void 0;
const type_object_assertions_1 = require("./type.object.assertions");
const type_common_assertions_1 = require("./type.common.assertions");
const type_array_assertions_1 = require("./type.array.assertions");
const type_number_asssertions_1 = require("./type.number.asssertions");
const type_string_assertions_1 = require("./type.string.assertions");
const assertions_utils_1 = require("./assertions.utils");
const error_1 = require("./error");
Object.defineProperty(exports, "AssertionError", { enumerable: true, get: function () { return error_1.AssertionError; } });
function initStepDeclarator(stepDeclarator) {
    assertions_utils_1._initStepDeclarator(stepDeclarator);
}
exports.initStepDeclarator = initStepDeclarator;
function _expect(actual, message, _isSoft = false) {
    return {
        get toExist() {
            return type_common_assertions_1.toExist(actual, message, _isSoft);
        },
        get toBeString() {
            return type_common_assertions_1.hasType(actual, 'string', message, _isSoft);
        },
        get toBeArray() {
            return type_common_assertions_1.hasType(actual, 'array', message, _isSoft);
        },
        get toBeObject() {
            return type_common_assertions_1.hasType(actual, 'object', message, _isSoft);
        },
        get toBeNull() {
            return type_common_assertions_1.hasType(actual, 'null', message, _isSoft);
        },
        get toBeNumber() {
            return type_common_assertions_1.hasType(actual, 'number', message, _isSoft);
        },
        get toBeUndefined() {
            return type_common_assertions_1.hasType(actual, 'undefined', message, _isSoft);
        },
        get toBeSet() {
            return type_common_assertions_1.hasType(actual, 'set', message, _isSoft);
        },
        get toBeFunction() {
            return type_common_assertions_1.hasType(actual, 'function', message, _isSoft);
        },
        get toBeAsyncFunction() {
            return type_common_assertions_1.hasType(actual, 'asyncFunction', message, _isSoft);
        },
        get toBePromise() {
            return type_common_assertions_1.hasType(actual, 'promise', message, _isSoft);
        },
        get toBeBool() {
            return type_common_assertions_1.hasType(actual, 'boolean', message, _isSoft);
        },
        get toBeSymbol() {
            return type_common_assertions_1.hasType(actual, 'symbol', message, _isSoft);
        },
        toEqual(expected, toEqualMessage) {
            type_common_assertions_1.toEqual(expected, actual, message || toEqualMessage, _isSoft);
        },
        toDeepEqual(expected, toEqualMessage) {
            type_common_assertions_1.toDeepEqual(expected, actual, message || toEqualMessage, _isSoft);
        },
        toBeEmptyArray(toEqualMessage) {
            type_array_assertions_1.toBeEmptyArray(actual, message || toEqualMessage, _isSoft);
        },
        toBeNotEmptyArray(toEqualMessage) {
            type_array_assertions_1.toBeNotEmptyArray(actual, message || toEqualMessage, _isSoft);
        },
        objectIncludesKeys(expected, toEqualMessage) {
            type_object_assertions_1.objectIncludesKeys(actual, expected, message || toEqualMessage, _isSoft);
        },
        hasType(expectedType, toEqualMessage) {
            type_common_assertions_1.hasType(actual, expectedType, message || toEqualMessage, _isSoft);
        },
        stringIncludesSubstring(subString, toEqualMessage) {
            type_string_assertions_1.stringIncludesSubstring(actual, subString, message || toEqualMessage, _isSoft);
        },
        stringNotIncludesSubstring(subString, toEqualMessage) {
            type_string_assertions_1.stringNotIncludesSubstring(actual, subString, message || toEqualMessage, _isSoft);
        },
        toNotEqual(expected, toEqualMessage) {
            type_common_assertions_1.toNotEqual(expected, actual, message || toEqualMessage, _isSoft);
        },
        toNotDeepEqual(expected, toEqualMessage) {
            type_common_assertions_1.toNotDeepEqual(expected, actual, message || toEqualMessage, _isSoft);
        },
        objectIsNotEmpty(toEqualMessage) {
            type_object_assertions_1.objectIsNotEmpty(actual, message || toEqualMessage, _isSoft);
        },
        objectIsEmpty(toEqualMessage) {
            type_object_assertions_1.objectIsEmpty(actual, message || toEqualMessage, _isSoft);
        },
        stringIsEmpty(toEqualMessage) {
            type_string_assertions_1.stringIsEmpty(actual, message || toEqualMessage, _isSoft);
        },
        stringIsNotEmpty(toEqualMessage) {
            type_string_assertions_1.stringIsNotEmpty(actual, message || toEqualMessage, _isSoft);
        },
        isGreaterThan(expected, toEqualMessage) {
            type_number_asssertions_1.isGreaterThan(actual, expected, message || toEqualMessage, _isSoft);
        },
        isLessThan(expected, toEqualMessage) {
            type_number_asssertions_1.isLessThan(actual, expected, message || toEqualMessage, _isSoft);
        },
        toMatchRegex(expected, toEqualMessage) {
            type_string_assertions_1.toMatchRegex(actual, expected, message || toEqualMessage, _isSoft);
        },
        arrayNotIncludesMembers(expected, toEqualMessage) {
            type_array_assertions_1.arrayNotIncludesMembers(expected, actual, message || toEqualMessage, _isSoft);
        },
        arrayIncludesMembers(expected, toEqualMessage) {
            type_array_assertions_1.arrayIncludesMembers(expected, actual, message || toEqualMessage, _isSoft);
        },
        arrayHasLengthAbove(expected, toEqualMessage) {
            type_array_assertions_1.arrayHasLengthAbove(actual, expected, message || toEqualMessage, _isSoft);
        }
    };
}
const expect = function (expected, message) {
    return _expect(expected, message);
};
exports.expect = expect;
expect.soft = function (expected, message) {
    return _expect(expected, message, true);
};
//# sourceMappingURL=index.js.map