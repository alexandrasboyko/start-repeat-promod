"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayHasLengthAbove = exports.arrayNotIncludesMembers = exports.arrayIncludesMembers = exports.toBeNotEmptyArray = exports.toBeEmptyArray = void 0;
const error_1 = require("./error");
const utils_1 = require("./utils");
const assertions_utils_1 = require("./assertions.utils");
function toBeNotEmptyArray(expected, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to be not empty array', expected);
    if (!Array.isArray(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('array', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (!expected.length) {
        resulter = new error_1.AssertionError({
            message: `${message}`,
            expected: `Expected array length > 0`,
            actual: `Actual array length ${expected.length}`,
            operator: 'toBeNotEmptyArray'
        });
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.toBeNotEmptyArray = toBeNotEmptyArray;
function toBeEmptyArray(expected, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to be empty array', expected);
    if (!Array.isArray(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('array', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (expected.length) {
        resulter = new error_1.AssertionError({
            message: `${message}`,
            expected: `Expected array length 0`,
            actual: `Actual array length ${expected.length}`,
            operator: 'toBeEmptyArray'
        });
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.toBeEmptyArray = toBeEmptyArray;
function arrayIncludesMembers(actual, expected, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to include', expected, actual);
    if (!Array.isArray(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('array', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    actual = Array.isArray(actual) ? actual : [actual];
    if (!actual.every((item) => expected.includes(item))) {
        resulter = new error_1.AssertionError({
            message: `${message}`,
            expected,
            actual,
            operator: 'arrayIncludesMembers'
        });
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.arrayIncludesMembers = arrayIncludesMembers;
function arrayNotIncludesMembers(actual, expected, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to not include', expected, actual);
    if (!Array.isArray(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('array', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    actual = Array.isArray(actual) ? actual : [actual];
    if (actual.every((item) => expected.includes(item))) {
        resulter = new error_1.AssertionError({
            message: `${message}`,
            expected,
            actual,
            operator: 'arrayNotIncludesMembers'
        });
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.arrayNotIncludesMembers = arrayNotIncludesMembers;
function arrayHasLengthAbove(array, length, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to have length above', array, length);
    if (!Array.isArray(array)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('array', array));
        return assertions_utils_1.postAssertCall(resulter, message, array, _isSoft);
    }
    if (array.length <= length) {
        resulter = new error_1.AssertionError({
            message: `${message}`,
            expected: length,
            actual: array.length,
            operator: 'arrayHasLengthAbove'
        });
        return assertions_utils_1.postAssertCall(resulter, message, array, _isSoft);
    }
    assertions_utils_1.postAssertCall(resulter, message, array, _isSoft);
}
exports.arrayHasLengthAbove = arrayHasLengthAbove;
//# sourceMappingURL=type.array.assertions.js.map