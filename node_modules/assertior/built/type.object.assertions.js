"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectIsEmpty = exports.objectIsNotEmpty = exports.objectIncludesMembers = exports.objectIncludesKeys = void 0;
const error_1 = require("./error");
const utils_1 = require("./utils");
const sat_utils_1 = require("sat-utils");
const assertions_utils_1 = require("./assertions.utils");
function includeMember(obj, member) {
    const objectKyes = Object.keys(obj);
    const memberKeys = Object.keys(member);
    let hasMember = false;
    const leyerKeysIncludes = memberKeys.every((key) => !objectKyes.includes(key));
    if (leyerKeysIncludes) {
        for (const key of objectKyes) {
            if (!(sat_utils_1.isPrimitive(obj[key]))) {
                hasMember = includeMember(obj[key], member);
            }
        }
    }
    else {
        memberKeys.every((key) => {
            const isKeyExist = objectKyes.find((k) => k === key);
            if (isKeyExist && sat_utils_1.isPrimitive(obj[key]) && sat_utils_1.isPrimitive(member[key])) {
                hasMember = obj[key] === member[key];
                return hasMember;
            }
        });
    }
    return hasMember;
}
function objectIsNotEmpty(expected, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to not be empty', expected);
    if (!sat_utils_1.isObject(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('object', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (expected) {
        const targetKeysList = Object.keys(expected);
        if (!targetKeysList.length) {
            resulter = new error_1.AssertionError({
                message,
                expected: ['some', 'keys', 'should', 'exist'],
                actual: targetKeysList,
                operator: 'objectIsNotEmpty'
            });
        }
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.objectIsNotEmpty = objectIsNotEmpty;
function objectIsEmpty(expected, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to be empty', expected);
    if (!sat_utils_1.isObject(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('object', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (expected) {
        const targetKeysList = Object.keys(expected);
        if (targetKeysList.length) {
            resulter = new error_1.AssertionError({
                message,
                expected: {},
                actual: expected,
                operator: 'objectIsEmpty'
            });
        }
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.objectIsEmpty = objectIsEmpty;
function objectIncludesKeys(object, keys, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to includes keys', object, keys);
    if (!sat_utils_1.isObject(object)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('object', object));
        return assertions_utils_1.postAssertCall(resulter, message, object, _isSoft);
    }
    if (!sat_utils_1.isArray(keys)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('array', keys));
        return assertions_utils_1.postAssertCall(resulter, message, object, _isSoft);
    }
    if (object) {
        const targetKeysList = Object.keys(object);
        if (!keys.every((expectedKey) => targetKeysList.includes(expectedKey))) {
            resulter = new error_1.AssertionError({
                message,
                expected: targetKeysList,
                actual: keys,
                operator: 'objectIncludesKeys'
            });
        }
    }
    assertions_utils_1.postAssertCall(resulter, message, object, _isSoft);
}
exports.objectIncludesKeys = objectIncludesKeys;
function objectIncludesMembers(expected, actual, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to includes member', expected, actual);
    if (!sat_utils_1.isObject(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('object', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (!sat_utils_1.isObject(actual)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('object', actual));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (expected) {
        if (!(Object.keys(actual).every((k) => Object.keys(expected).includes(k)))) {
            resulter = new error_1.AssertionError({
                message,
                expected,
                actual,
                operator: 'objectIncludesMembers'
            });
            return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
        }
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.objectIncludesMembers = objectIncludesMembers;
//# sourceMappingURL=type.object.assertions.js.map