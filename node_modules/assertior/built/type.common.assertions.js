"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toExist = exports.toNotDeepEqual = exports.toNotEqual = exports.hasType = exports.toDeepEqual = exports.toEqual = void 0;
const assert_1 = require("assert");
const utils_1 = require("./utils");
const assertions_utils_1 = require("./assertions.utils");
const sat_utils_1 = require("sat-utils");
const error_1 = require("./error");
function toEqual(expected, actual, message, _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to equal', expected, actual);
    if (expected !== actual) {
        resulter = new error_1.AssertionError({
            message,
            expected,
            actual,
            operator: 'toEqual'
        });
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft, actual);
}
exports.toEqual = toEqual;
function toNotEqual(expected, actual, message, _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to not equal', expected, actual);
    if (expected === actual) {
        resulter = new error_1.AssertionError({
            message,
            expected,
            actual,
            operator: 'toNotEqual'
        });
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft, actual);
}
exports.toNotEqual = toNotEqual;
function toDeepEqual(expected, actual, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to deep equal', expected, actual);
    try {
        assert_1.deepStrictEqual(expected, actual, message);
    }
    catch (error) {
        resulter = error;
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft, actual);
}
exports.toDeepEqual = toDeepEqual;
function toNotDeepEqual(expected, actual, message = '', _isSoft = false) {
    message = message ? message : utils_1.buildDefaultMessage('to not deep equal', expected, actual);
    let resulter = new error_1.AssertionError({
        message,
        expected,
        actual,
        operator: 'toNotDeepEqual'
    });
    try {
        assert_1.deepStrictEqual(expected, actual, message);
    }
    catch (error) {
        resulter = null;
    }
    return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft, actual);
}
exports.toNotDeepEqual = toNotDeepEqual;
function toExist(expected, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to exist', expected);
    const hasTypeResult = sat_utils_1.isNull(expected) || sat_utils_1.isUndefined(expected);
    if (hasTypeResult) {
        resulter = new error_1.AssertionError({
            message,
            expected: 'not undefined and not null',
            actual: sat_utils_1.getType(expected),
            operator: 'toExist'
        });
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.toExist = toExist;
function hasType(expected, expectedType, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('has type', expected, expectedType);
    if (!(expectedType in sat_utils_1.typesEnum)) {
        resulter = new TypeError(`Type ${expectedType} does not exist, available types are: ${Object.keys(sat_utils_1.typesEnum).join(',')}`);
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft, expectedType);
    }
    const hasTypeResult = sat_utils_1.isType(expected, expectedType);
    if (!hasTypeResult) {
        resulter = new error_1.AssertionError({
            message,
            expected: sat_utils_1.getType(expected),
            actual: expectedType,
            operator: 'hasType'
        });
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft, expectedType);
    }
    return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft, expectedType);
}
exports.hasType = hasType;
//# sourceMappingURL=type.common.assertions.js.map