"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toMatchRegex = exports.stringIsEmpty = exports.stringIsNotEmpty = exports.stringNotIncludesSubstring = exports.stringIncludesSubstring = void 0;
const error_1 = require("./error");
const utils_1 = require("./utils");
const sat_utils_1 = require("sat-utils");
const assertions_utils_1 = require("./assertions.utils");
function stringIncludesSubstring(expected, actual, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to includes substring', expected, actual);
    if (!sat_utils_1.isString(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('string', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (!sat_utils_1.isString(actual)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('string', actual));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    const isIncludes = expected.includes(actual);
    if (!isIncludes) {
        resulter = new error_1.AssertionError({
            message,
            expected,
            actual,
            operator: 'stringIncludesSubstring'
        });
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.stringIncludesSubstring = stringIncludesSubstring;
function stringNotIncludesSubstring(expected, actual, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to not includes substring', expected, actual);
    if (!sat_utils_1.isString(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('string', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (!sat_utils_1.isString(actual)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('string', actual));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    const isIncludes = expected.includes(actual);
    if (isIncludes) {
        resulter = new error_1.AssertionError({
            message,
            expected,
            actual,
            operator: 'stringNotIncludesSubstring'
        });
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.stringNotIncludesSubstring = stringNotIncludesSubstring;
function stringIsNotEmpty(expected, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to be not empty', expected);
    if (!sat_utils_1.isString(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('string', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (!expected.length) {
        resulter = new error_1.AssertionError({
            message,
            expected,
            actual: '',
            operator: 'stringIsNotEmpty'
        });
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.stringIsNotEmpty = stringIsNotEmpty;
function stringIsEmpty(expected, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to be empty', expected);
    if (!sat_utils_1.isString(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('string', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (expected.length) {
        resulter = new error_1.AssertionError({
            message,
            expected: '',
            actual: expected,
            operator: 'stringIsEmpty'
        });
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.stringIsEmpty = stringIsEmpty;
function toMatchRegex(expected, actual, message = '', _isSoft = false) {
    let resulter;
    message = message ? message : utils_1.buildDefaultMessage('to match regex', expected);
    if (!sat_utils_1.isString(expected)) {
        resulter = new TypeError(utils_1.buildTypeErrorMessage('string', expected));
        return assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
    }
    if (!expected.match(actual)) {
        resulter = new error_1.AssertionError({
            message,
            expected: '',
            actual: expected,
            operator: 'toMatchRegex'
        });
    }
    assertions_utils_1.postAssertCall(resulter, message, expected, _isSoft);
}
exports.toMatchRegex = toMatchRegex;
//# sourceMappingURL=type.string.assertions.js.map